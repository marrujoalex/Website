{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to OpenKitten\n\n\nOpenKitten is a Server Side Swift ecosystem. It contains many libraries for creating backends and full stack swift applications.\n\n\nWe're active on \nSlack\n and \nGithub\n.\n\n\nThe libraries\n\n\nThe libraries can be categorized into 3 categories.\n\n\nHTTP\n\n\nLeopard\n is a high performance web framework based on \nLynx\n.\n\n\nPuma\n is a \nLynx\n based HTTP client. Designed to work seamlessly with \nLeopard\n .\n\n\nLynx\n is the HTTP core, containing an HTTP server and all basic features of HTTP messages. It relies on \nSchrodinger\n to provide clean asynchronous data flows.\n\n\nMongoDB\n\n\nMongoKitten\n is the fastest MongoDB driver. It's also the only pure-swift MongoDB driver. It relies heavily upon \nBSON\n and assumes familiarity with \nBSON\n.\n\n\nMeow\n is a codable ORM based on \nMongoKitten\n. It's flexible and boilerplate-free, allowing your models to stay clean.\n\n\nUtility\n\n\nCheetah\n is a JSON library that supports Swift 4 codables. In addition to that, it shares an API that fits right in with Swift and other OpenKitten libraries.\n\n\nOcelot\n is a JWT library that also supports codables for decoding JWTs. It leans on \nCheetah\n for JSON data.\n\n\nSchrodinger\n is the promise library, used for asynchronous data flow.\n\n\nThird party\n\n\nWe're happy to work with the community and assist writing good libraries. Some problems are already solved by a third party without much room for improvement. These are such libraries.\n\n\nThe following libraries are not supported by us directly, although we advice using them if they're useful to you.\n\n\nJobs\n is a minimalistic job system in Swift. It doesn't store jobs on application exit/restart.\n\n\nRequirements\n\n\nThese projects require the Swift 4 07-20 snapshot or the Xcode 9 build for macOS.\n\n\nLinux - Ubuntu 16.04\n\n\nLinux - Ubuntu 14.04\n\n\nmacOS - Manual download\n\n\nOr just install the latest Xcode 9 beta (beta 4 or greater).\n\n\nLinux\n\n\nFor SSL, Linux requires the installation of \nlibssl-dev\n, \nopenssl\n and Swift 4.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-openkitten", 
            "text": "OpenKitten is a Server Side Swift ecosystem. It contains many libraries for creating backends and full stack swift applications.  We're active on  Slack  and  Github .", 
            "title": "Welcome to OpenKitten"
        }, 
        {
            "location": "/#the-libraries", 
            "text": "The libraries can be categorized into 3 categories.", 
            "title": "The libraries"
        }, 
        {
            "location": "/#http", 
            "text": "Leopard  is a high performance web framework based on  Lynx .  Puma  is a  Lynx  based HTTP client. Designed to work seamlessly with  Leopard  .  Lynx  is the HTTP core, containing an HTTP server and all basic features of HTTP messages. It relies on  Schrodinger  to provide clean asynchronous data flows.", 
            "title": "HTTP"
        }, 
        {
            "location": "/#mongodb", 
            "text": "MongoKitten  is the fastest MongoDB driver. It's also the only pure-swift MongoDB driver. It relies heavily upon  BSON  and assumes familiarity with  BSON .  Meow  is a codable ORM based on  MongoKitten . It's flexible and boilerplate-free, allowing your models to stay clean.", 
            "title": "MongoDB"
        }, 
        {
            "location": "/#utility", 
            "text": "Cheetah  is a JSON library that supports Swift 4 codables. In addition to that, it shares an API that fits right in with Swift and other OpenKitten libraries.  Ocelot  is a JWT library that also supports codables for decoding JWTs. It leans on  Cheetah  for JSON data.  Schrodinger  is the promise library, used for asynchronous data flow.", 
            "title": "Utility"
        }, 
        {
            "location": "/#third-party", 
            "text": "We're happy to work with the community and assist writing good libraries. Some problems are already solved by a third party without much room for improvement. These are such libraries.  The following libraries are not supported by us directly, although we advice using them if they're useful to you.  Jobs  is a minimalistic job system in Swift. It doesn't store jobs on application exit/restart.", 
            "title": "Third party"
        }, 
        {
            "location": "/#requirements", 
            "text": "These projects require the Swift 4 07-20 snapshot or the Xcode 9 build for macOS.  Linux - Ubuntu 16.04  Linux - Ubuntu 14.04  macOS - Manual download  Or just install the latest Xcode 9 beta (beta 4 or greater).", 
            "title": "Requirements"
        }, 
        {
            "location": "/#linux", 
            "text": "For SSL, Linux requires the installation of  libssl-dev ,  openssl  and Swift 4.", 
            "title": "Linux"
        }, 
        {
            "location": "/leopard/", 
            "text": "Leopard basics\n\n\nLeopard is a high performance web framework, built 100% in Swift. It provides an easy to use async API.\n\n\nThis guide will help you set up Leopard from your terminal. It assumes Swift 4 has been set up.\n\n\nSPM - Package.swift\n\n\nWhen creating a project using \nswift package init --type=executable\n, you'll notice that a set of files and directories have appeared in the current directory. One of these files is \nPackage.swift\n, the project definition.\n\n\nIn here, a basic template will be shown. Let's add Leopard to that using:\n\n\n.package(url: \nhttps://github.com/OpenKitten/Leopard.git\n, .revision(\nmaster\n)),\n\n\n\n\nAnd by adding \n\"Leopard\"\n to your target's dependencies.\n\n\n// swift-tools-version:4.0\n// The swift-tools-version declares the minimum version of Swift required to build this package.\n\nimport PackageDescription\n\nlet package = Package(\n    name: \nExample\n,\n    dependencies: [\n        .package(url: \nhttps://github.com/OpenKitten/Leopard.git\n, .exact(\n1.0.0-beta1\n)),\n    ],\n    targets: [\n        .target(\n            name: \nExample\n,\n            dependencies: [\nLeopard\n]),\n    ]\n)\n\n\n\n\nA basic HTTP server\n\n\nAfter \nimport Leopard\n has been put on top of your \nmain.swift\n, you'll need to create an \nAsyncWebServer\n like so:\n\n\n// Create an HTTP server at port `80`\nlet server = try WebServer()\n\n// TODO: Set up routes\n\n// start the server\ntry server.start()\n\n\n\n\nThis is almost identical to the sync webserver.\n\n\nBasic routes are more complex than sync routes and provide no benefit with plaintext requests.\n\n\nAsync requests always require a future to be returned as a response.\n\n\nserver.get(\npath\n, \nto\n, \nroute\n) { request in\n  return Future { \nHello world\n }\n}\n\n\n\n\nThe following also creates a \nGET /path/to/route\n handler that always returns \n\"Hello world\"\n.", 
            "title": "Leopard Basics"
        }, 
        {
            "location": "/leopard/#leopard-basics", 
            "text": "Leopard is a high performance web framework, built 100% in Swift. It provides an easy to use async API.  This guide will help you set up Leopard from your terminal. It assumes Swift 4 has been set up.", 
            "title": "Leopard basics"
        }, 
        {
            "location": "/leopard/#spm-packageswift", 
            "text": "When creating a project using  swift package init --type=executable , you'll notice that a set of files and directories have appeared in the current directory. One of these files is  Package.swift , the project definition.  In here, a basic template will be shown. Let's add Leopard to that using:  .package(url:  https://github.com/OpenKitten/Leopard.git , .revision( master )),  And by adding  \"Leopard\"  to your target's dependencies.  // swift-tools-version:4.0\n// The swift-tools-version declares the minimum version of Swift required to build this package.\n\nimport PackageDescription\n\nlet package = Package(\n    name:  Example ,\n    dependencies: [\n        .package(url:  https://github.com/OpenKitten/Leopard.git , .exact( 1.0.0-beta1 )),\n    ],\n    targets: [\n        .target(\n            name:  Example ,\n            dependencies: [ Leopard ]),\n    ]\n)", 
            "title": "SPM - Package.swift"
        }, 
        {
            "location": "/leopard/#a-basic-http-server", 
            "text": "After  import Leopard  has been put on top of your  main.swift , you'll need to create an  AsyncWebServer  like so:  // Create an HTTP server at port `80`\nlet server = try WebServer()\n\n// TODO: Set up routes\n\n// start the server\ntry server.start()  This is almost identical to the sync webserver.  Basic routes are more complex than sync routes and provide no benefit with plaintext requests.  Async requests always require a future to be returned as a response.  server.get( path ,  to ,  route ) { request in\n  return Future {  Hello world  }\n}  The following also creates a  GET /path/to/route  handler that always returns  \"Hello world\" .", 
            "title": "A basic HTTP server"
        }, 
        {
            "location": "/leopard/advanced-routing/", 
            "text": "Advanced routing\n\n\nRouting can become more complex the more your application grows, so grouping routes and handlers is an essential part of any web framework.\n\n\nWe also support middlewares with the requirement of them being asynchronous.\n\n\nGrouping\n\n\nCreating a group is similar to creating a route, only the route group get's returned.\n\n\nlet apiV1group = webserver.grouped(\napi\n, \nv1\n)\n\n// GET `/api/v1/users`\napiV1Group.get(\nusers\n) { request in\n  ...\n}\n\n\n\n\nYou can chain groups indefinitely.\n\n\nlet api = webserver.grouped(\napi\n)\n\n// `/api/v1/...`\nlet v1 = api.grouped(\nv1\n)\n\n// `/api/v2/...`\nlet v2 = api.grouped(\nv2\n)\n\n// `/api/v3/...`\nlet v3 = api.grouped(\nv3\n)\n\n\n\n\nTo improve the syntax, we also implement the \ngroup\n function with a trailing closure.\n\n\nwebserver.group(\napi\n) { api in\n  api.group(\nv1\n) { v1 in\n    v1.get(\nusers\n) { request in\n      ...\n    }\n  }\n}", 
            "title": "Advanced routing"
        }, 
        {
            "location": "/leopard/advanced-routing/#advanced-routing", 
            "text": "Routing can become more complex the more your application grows, so grouping routes and handlers is an essential part of any web framework.  We also support middlewares with the requirement of them being asynchronous.", 
            "title": "Advanced routing"
        }, 
        {
            "location": "/leopard/advanced-routing/#grouping", 
            "text": "Creating a group is similar to creating a route, only the route group get's returned.  let apiV1group = webserver.grouped( api ,  v1 )\n\n// GET `/api/v1/users`\napiV1Group.get( users ) { request in\n  ...\n}  You can chain groups indefinitely.  let api = webserver.grouped( api )\n\n// `/api/v1/...`\nlet v1 = api.grouped( v1 )\n\n// `/api/v2/...`\nlet v2 = api.grouped( v2 )\n\n// `/api/v3/...`\nlet v3 = api.grouped( v3 )  To improve the syntax, we also implement the  group  function with a trailing closure.  webserver.group( api ) { api in\n  api.group( v1 ) { v1 in\n    v1.get( users ) { request in\n      ...\n    }\n  }\n}", 
            "title": "Grouping"
        }, 
        {
            "location": "/leopard/errors/", 
            "text": "Errors\n\n\nErrors are an important part of websites. They happen all the time. When authentication fails, the database connection drops or even when an unexpected condition triggers.\n\n\nLogging\n\n\nLogging is an important part of your code, since it tells you what's happening at different levels. One might read verbose messages reporting every login attempt or just the warnings indicating a potential brute force.\n\n\nErrors aren't easy to capture in a single \"mold\", everyone has their own method of organising errors.\n\n\nBy making your structs/classes \nEncodable\n, you enable the ability to log these entities to the currently selected logger/log destination.\n\n\nstruct LoginError : Error, Encodable {\n  let username: String\n}\n\nApplication.logger?.log(LoginError(username: \nJoannis\n), level: .warning)\n\n\n\n\nChangning the destination\n\n\nSetting the logger can be done on the static property \nlogger\n on \nApplication\n.\n\n\nApplication.logger = MyCustomLogger()", 
            "title": "Errors"
        }, 
        {
            "location": "/leopard/errors/#errors", 
            "text": "Errors are an important part of websites. They happen all the time. When authentication fails, the database connection drops or even when an unexpected condition triggers.", 
            "title": "Errors"
        }, 
        {
            "location": "/leopard/errors/#logging", 
            "text": "Logging is an important part of your code, since it tells you what's happening at different levels. One might read verbose messages reporting every login attempt or just the warnings indicating a potential brute force.  Errors aren't easy to capture in a single \"mold\", everyone has their own method of organising errors.  By making your structs/classes  Encodable , you enable the ability to log these entities to the currently selected logger/log destination.  struct LoginError : Error, Encodable {\n  let username: String\n}\n\nApplication.logger?.log(LoginError(username:  Joannis ), level: .warning)", 
            "title": "Logging"
        }, 
        {
            "location": "/leopard/errors/#changning-the-destination", 
            "text": "Setting the logger can be done on the static property  logger  on  Application .  Application.logger = MyCustomLogger()", 
            "title": "Changning the destination"
        }, 
        {
            "location": "/leopard/config/", 
            "text": "Configuration files\n\n\nConfiguration files in Leopard can be any format. However, only JSON is included by default. Your Config file needs to be a \nstruct\n conforming to the \nConfig\n protocol.\n\n\nFrom here, you can include other configuration related protocols, too. As your config file imports more configuration types, the more complex it gets and the more requirements there are to the file on the disk.\n\n\nHowever, there's nothing preventing embedded, referenced (class) or even multiple config files being used.\n\n\nLeopard Configuration\n\n\nLeopard comes with two default configuration file protocols.\n\n\nHTTPServerConfig\n is used for configuring the HTTP server's port and hostname.\n\n\nRoutingConfig\n allows customizing the token prefix for parameterized route compoenents.\n\n\nYou can inherit from both protocols, which would make you end up with the following:\n\n\nstruct ExampleConfig : Config, HTTPServerConfig RoutingConfig {\n    var routeParameterToken: String? = \n:\n\n    var port: UInt16 = 80\n    var hostname: String = \n0.0.0.0\n\n}", 
            "title": "Configuration"
        }, 
        {
            "location": "/leopard/config/#configuration-files", 
            "text": "Configuration files in Leopard can be any format. However, only JSON is included by default. Your Config file needs to be a  struct  conforming to the  Config  protocol.  From here, you can include other configuration related protocols, too. As your config file imports more configuration types, the more complex it gets and the more requirements there are to the file on the disk.  However, there's nothing preventing embedded, referenced (class) or even multiple config files being used.", 
            "title": "Configuration files"
        }, 
        {
            "location": "/leopard/config/#leopard-configuration", 
            "text": "Leopard comes with two default configuration file protocols.  HTTPServerConfig  is used for configuring the HTTP server's port and hostname.  RoutingConfig  allows customizing the token prefix for parameterized route compoenents.  You can inherit from both protocols, which would make you end up with the following:  struct ExampleConfig : Config, HTTPServerConfig RoutingConfig {\n    var routeParameterToken: String? =  : \n    var port: UInt16 = 80\n    var hostname: String =  0.0.0.0 \n}", 
            "title": "Leopard Configuration"
        }, 
        {
            "location": "/leopard/request-response/", 
            "text": "Request \n Response\n\n\nRequest and response are at the heart of HTTP, therefore they are extremely important. They've got two things in common: Headers and Body.\n\n\nBoth Request and Response\n\n\nBoth Request and Response share similarities. One is the sender and the other the receiver. Requests get sent, responses get sent back.\n\n\nHeaders\n\n\nHeaders contain metadata such as the timestamp, name and MIME-type of a file. Or such as the cookies carried over from previous sessions.\n\n\nThey can be instantiated with a literal or using an empty initializer.\n\n\nlet emptyHeaders = Headers()\nlet emptyHeaders2: Headers = [:]\n\n\n\n\nHeaders can be read and written.\n\n\nlet headers = Headers()\n\nheaders[\nAuthorization\n] = \nbearer dasdwqjrnajdfnasdsiwq\n\nprint(String(headers[\nAuthorization\n]))\n\nlet otherHeaders: Headers = [\n  \nAuthorization\n: \nbearer dasdwqjrnajdfnasdsiwq\n\n]\n\n\n\n\nBody\n\n\nBodies are a blob of undefined information. It may contain any kind of data, including but not limited to HTML, plain text, CSS, images, videos.\n\n\nWriting to a body using a previously supported object is easy:\n\n\nlet testBody = try \ntest\n.makeBody()\n\n\n\n\nSome of the supported body types are:\n\n\nCheetah.JSONObject\n, \nCheetah.JSONArray\n, \nString\n, \nBody\n\n\nConverting from a body to an existing type is simple to implement:\n\n\nextension BodyRepresentable {\n  func convertToCustomType() throws -\n CustomType {\n    let buffer = try self.makeBody().buffer\n\n    return CustomType(from: buffer)\n  }\n}\n\nlet customEntity = try request.body.convertToCustomType()\n\n\n\n\nJSONObject is already implemented for you, so you can try to read that from a Body using:\n\n\nguard let object = request.jsonObject else {\n  ... // handle data isn't a JSONObject\n}\n\n\n\n\nMore about JSON here.\n\n\nBodyRepresentable\n\n\nThe other way around is useful, too. Converting your own type of data to a Body can be useful when you're writing your own templating tool, for example.\n\n\nextension CustomType : BodyRepresentable {\n  public func makeBody() throws -\n Body {\n    return Body(self.makeBytes()) // serialize this entity to binary\n  }\n}\n\n\n\n\nOnly Request\n\n\nRequests are unique in them carrying a method and a path. The path can contain query parameters in the URL. All of this allows for very specfic queries to be made.\n\n\nMethod\n\n\nMethod is an enum. It exists of a specific type of action.\n\n\nGET\n is used for fetching entities' their data.\n\n\nHEAD\n is used for fetching entities' their metadata.\n\n\nPOST\n is used to create entities\n\n\nPUT\n is used to replace created entities with a new entity\n\n\nPATCH\n is used to update part of an entity\n\n\nDELETE\n is used to delete an entity\n\n\nBesides this, custom methods are also possible, or less commonly used methods.\n\n\nPath\n\n\nThe path describes the requested URL. It doesn't have many features publically available yet.\n\n\nQuery parameters and Forms\n\n\nBoth query parameters and simple HTML forms use query encoding. This means that their API is equal.\n\n\nguard let query: Query = request.body?.query else {\n  // handle invalid body\n}\n\nguard let username: String = query[\nusername\n] else {\n  // handle invalid request\n}\n\n\n\n\nMultipart forms\n\n\nTODO: File uploading needs to be fixed before continuing documentation here\n\n\nCreating a request\n\n\nCreating a request requires at least a methodana path.\n\n\nThis might end up like one of the following:\n\n\nlet request0 = Request(method: .get, path: \n/users/test\n, headers: [\n  \nHost\n: \nexample.com\n\n])\n\nlet request1 = Request(method: \nDELETE\n, path: \n/\n, headers: [\n  \nHost\n: \nexample.com\n\n])\n\nlet json: JSONObject = [\n  \nusername\n: \nJoannisO\n,\n  \npassword\n: \nop3nkitt3n\n\n]\n\nlet request2 = Request(method: .post, path: \n/users/register\n, body: try json.makeBody())\n\n\n\n\nOnly Response\n\n\nResponses are unique in their response status codes. They're used to indicate the successfull execution of a request, or it's failure.\n\n\nStatus code\n\n\nHTTP status codes indicate one of five things.\n\n\n\n\n1xx\n an informational response\n\n\n2xx\n The operation was successfull\n\n\n3xx\n Redirecting is necessary\n\n\n4xx\n A client-side error occurred\n\n\n5xx\n A server-side error occurred\n\n\n\n\nMore information on status codes is available here\n\n\nCreating a response\n\n\nResponses only require a status code, but usually also provide headers and a body.\n\n\nlet response0 = Response(status: .ok)\n\nlet response1 = Response(status: .notFound, body: \nNot Found\n)\n\nlet response2 = Response(status: 500, headers: [\n  \nHeaderKey\n: \nValue\n\n])", 
            "title": "Request & Response"
        }, 
        {
            "location": "/leopard/request-response/#request-response", 
            "text": "Request and response are at the heart of HTTP, therefore they are extremely important. They've got two things in common: Headers and Body.", 
            "title": "Request &amp; Response"
        }, 
        {
            "location": "/leopard/request-response/#both-request-and-response", 
            "text": "Both Request and Response share similarities. One is the sender and the other the receiver. Requests get sent, responses get sent back.", 
            "title": "Both Request and Response"
        }, 
        {
            "location": "/leopard/request-response/#headers", 
            "text": "Headers contain metadata such as the timestamp, name and MIME-type of a file. Or such as the cookies carried over from previous sessions.  They can be instantiated with a literal or using an empty initializer.  let emptyHeaders = Headers()\nlet emptyHeaders2: Headers = [:]  Headers can be read and written.  let headers = Headers()\n\nheaders[ Authorization ] =  bearer dasdwqjrnajdfnasdsiwq \nprint(String(headers[ Authorization ]))\n\nlet otherHeaders: Headers = [\n   Authorization :  bearer dasdwqjrnajdfnasdsiwq \n]", 
            "title": "Headers"
        }, 
        {
            "location": "/leopard/request-response/#body", 
            "text": "Bodies are a blob of undefined information. It may contain any kind of data, including but not limited to HTML, plain text, CSS, images, videos.  Writing to a body using a previously supported object is easy:  let testBody = try  test .makeBody()  Some of the supported body types are:  Cheetah.JSONObject ,  Cheetah.JSONArray ,  String ,  Body  Converting from a body to an existing type is simple to implement:  extension BodyRepresentable {\n  func convertToCustomType() throws -  CustomType {\n    let buffer = try self.makeBody().buffer\n\n    return CustomType(from: buffer)\n  }\n}\n\nlet customEntity = try request.body.convertToCustomType()  JSONObject is already implemented for you, so you can try to read that from a Body using:  guard let object = request.jsonObject else {\n  ... // handle data isn't a JSONObject\n}  More about JSON here.", 
            "title": "Body"
        }, 
        {
            "location": "/leopard/request-response/#bodyrepresentable", 
            "text": "The other way around is useful, too. Converting your own type of data to a Body can be useful when you're writing your own templating tool, for example.  extension CustomType : BodyRepresentable {\n  public func makeBody() throws -  Body {\n    return Body(self.makeBytes()) // serialize this entity to binary\n  }\n}", 
            "title": "BodyRepresentable"
        }, 
        {
            "location": "/leopard/request-response/#only-request", 
            "text": "Requests are unique in them carrying a method and a path. The path can contain query parameters in the URL. All of this allows for very specfic queries to be made.", 
            "title": "Only Request"
        }, 
        {
            "location": "/leopard/request-response/#method", 
            "text": "Method is an enum. It exists of a specific type of action.  GET  is used for fetching entities' their data.  HEAD  is used for fetching entities' their metadata.  POST  is used to create entities  PUT  is used to replace created entities with a new entity  PATCH  is used to update part of an entity  DELETE  is used to delete an entity  Besides this, custom methods are also possible, or less commonly used methods.", 
            "title": "Method"
        }, 
        {
            "location": "/leopard/request-response/#path", 
            "text": "The path describes the requested URL. It doesn't have many features publically available yet.", 
            "title": "Path"
        }, 
        {
            "location": "/leopard/request-response/#query-parameters-and-forms", 
            "text": "Both query parameters and simple HTML forms use query encoding. This means that their API is equal.  guard let query: Query = request.body?.query else {\n  // handle invalid body\n}\n\nguard let username: String = query[ username ] else {\n  // handle invalid request\n}", 
            "title": "Query parameters and Forms"
        }, 
        {
            "location": "/leopard/request-response/#multipart-forms", 
            "text": "TODO: File uploading needs to be fixed before continuing documentation here", 
            "title": "Multipart forms"
        }, 
        {
            "location": "/leopard/request-response/#creating-a-request", 
            "text": "Creating a request requires at least a methodana path.  This might end up like one of the following:  let request0 = Request(method: .get, path:  /users/test , headers: [\n   Host :  example.com \n])\n\nlet request1 = Request(method:  DELETE , path:  / , headers: [\n   Host :  example.com \n])\n\nlet json: JSONObject = [\n   username :  JoannisO ,\n   password :  op3nkitt3n \n]\n\nlet request2 = Request(method: .post, path:  /users/register , body: try json.makeBody())", 
            "title": "Creating a request"
        }, 
        {
            "location": "/leopard/request-response/#only-response", 
            "text": "Responses are unique in their response status codes. They're used to indicate the successfull execution of a request, or it's failure.", 
            "title": "Only Response"
        }, 
        {
            "location": "/leopard/request-response/#status-code", 
            "text": "HTTP status codes indicate one of five things.   1xx  an informational response  2xx  The operation was successfull  3xx  Redirecting is necessary  4xx  A client-side error occurred  5xx  A server-side error occurred   More information on status codes is available here", 
            "title": "Status code"
        }, 
        {
            "location": "/leopard/request-response/#creating-a-response", 
            "text": "Responses only require a status code, but usually also provide headers and a body.  let response0 = Response(status: .ok)\n\nlet response1 = Response(status: .notFound, body:  Not Found )\n\nlet response2 = Response(status: 500, headers: [\n   HeaderKey :  Value \n])", 
            "title": "Creating a response"
        }, 
        {
            "location": "/leopard/cookies-sessions/", 
            "text": "Cookies \n Sessions\n\n\nCookies play an important role in persistence. They allow the server and client to share a storage that can be modified by either party.\n\n\nCookies are often used for managing sessions.\n\n\nReading a request's Cookies\n\n\nlet cookies = request.cookies\n\nguard let sessionToken = String(cookies[\nsession\n]) else {\n  ...\n}\n\n\n\n\nSessions\n\n\nSession are currently supported through \nJWT using Ocelot.\n\n\nJWT has proven to be flexible, easy and powerful at the same time. If you want simple token based sessions, we currently recommend managing the session in the \nin-memory cache\n or the database of your choice.", 
            "title": "Cookies & Sessions"
        }, 
        {
            "location": "/leopard/cookies-sessions/#cookies-sessions", 
            "text": "Cookies play an important role in persistence. They allow the server and client to share a storage that can be modified by either party.  Cookies are often used for managing sessions.", 
            "title": "Cookies &amp; Sessions"
        }, 
        {
            "location": "/leopard/cookies-sessions/#reading-a-requests-cookies", 
            "text": "let cookies = request.cookies\n\nguard let sessionToken = String(cookies[ session ]) else {\n  ...\n}", 
            "title": "Reading a request's Cookies"
        }, 
        {
            "location": "/leopard/cookies-sessions/#sessions", 
            "text": "Session are currently supported through  JWT using Ocelot.  JWT has proven to be flexible, easy and powerful at the same time. If you want simple token based sessions, we currently recommend managing the session in the  in-memory cache  or the database of your choice.", 
            "title": "Sessions"
        }, 
        {
            "location": "/leopard/middlewares/", 
            "text": "Middlewares\n\n\nLeopard middlewares are exclusively asynchronous. This ensures quality between all middleware consumers.\n\n\nMiddlewares\n\n\nAlternatively you can create a normal, more complex Middleware which gives you direct control over the connection. This way you can implement protocol upgrades such as the included WebSocket implementation.\n\n\nclass MyComplexMiddleware : Middlware {\n  func handle(_ request: Request, for remote: HTTPRemote, chainingTo handler: RequestHandler) {\n    guard request.headers.bearer == \nmy-hardcoded-token\n else {\n      remote.send(Response(status: .internalServerError))\n      return\n    }\n\n    handler(request, remote)\n  }\n}\n\n\n\n\nThis function does not allow you to throw errors. Instead, the HTTPRemote should be sent the Error so it can deal with it appropriately.\nMore about \nHTTPRemote here.", 
            "title": "Middlwares"
        }, 
        {
            "location": "/leopard/middlewares/#middlewares", 
            "text": "Leopard middlewares are exclusively asynchronous. This ensures quality between all middleware consumers.", 
            "title": "Middlewares"
        }, 
        {
            "location": "/leopard/middlewares/#middlewares_1", 
            "text": "Alternatively you can create a normal, more complex Middleware which gives you direct control over the connection. This way you can implement protocol upgrades such as the included WebSocket implementation.  class MyComplexMiddleware : Middlware {\n  func handle(_ request: Request, for remote: HTTPRemote, chainingTo handler: RequestHandler) {\n    guard request.headers.bearer ==  my-hardcoded-token  else {\n      remote.send(Response(status: .internalServerError))\n      return\n    }\n\n    handler(request, remote)\n  }\n}  This function does not allow you to throw errors. Instead, the HTTPRemote should be sent the Error so it can deal with it appropriately.\nMore about  HTTPRemote here.", 
            "title": "Middlewares"
        }, 
        {
            "location": "/leopard/websocket/", 
            "text": "WebSocket\n\n\nWebSockets are useful when you want a real-time connection between client and server. WebSockets allow both parties to send each other information at any time. And support text as well as binary messages.\n\n\nCreating a websocket route\n\n\nThis example assumes you've got a variable \nrouter\n that is a \nWebSocketRouter\n.\n\n\nrouter.websocket(\napi\n, \nv1\n, \nwebsocket\n) { client in\n  // set up handlers\n}\n\n\n\n\nThe handler will be called only when a successful WebSocket connection has been instantiated at this route. It doesn't do anything yet and will disconnect almost immediately.\n\n\nAdding a listener\n\n\nrouter.websocket(\napi\n, \nv1\n, \nwebsocket\n) { client in\n  client.onText { message in\n    // echo the message back\n    try client.send(message)\n  }\n}", 
            "title": "WebSocket"
        }, 
        {
            "location": "/leopard/websocket/#websocket", 
            "text": "WebSockets are useful when you want a real-time connection between client and server. WebSockets allow both parties to send each other information at any time. And support text as well as binary messages.", 
            "title": "WebSocket"
        }, 
        {
            "location": "/leopard/websocket/#creating-a-websocket-route", 
            "text": "This example assumes you've got a variable  router  that is a  WebSocketRouter .  router.websocket( api ,  v1 ,  websocket ) { client in\n  // set up handlers\n}  The handler will be called only when a successful WebSocket connection has been instantiated at this route. It doesn't do anything yet and will disconnect almost immediately.", 
            "title": "Creating a websocket route"
        }, 
        {
            "location": "/leopard/websocket/#adding-a-listener", 
            "text": "router.websocket( api ,  v1 ,  websocket ) { client in\n  client.onText { message in\n    // echo the message back\n    try client.send(message)\n  }\n}", 
            "title": "Adding a listener"
        }, 
        {
            "location": "/puma/", 
            "text": "Puma\n\n\nPuma is an HTTP Client based on Lynx. Because it's build on Lynx it integrates with any extensions and features added on top o Lynx, such as JSON and file uploading.\n\n\nA single request/response\n\n\nPuma is designed asynchronously, we only exposed the synchronous API so far.\n\n\nA request is made the same way any of our requests are made \nas described here.\n\n\nYou can then create an HTTP client:\n\n\n// Creates a client for https://example.com\nlet response = SyncHTTPClient.send(request, toHost: \nexample.com\n, securely: true)", 
            "title": "HTTP client"
        }, 
        {
            "location": "/puma/#puma", 
            "text": "Puma is an HTTP Client based on Lynx. Because it's build on Lynx it integrates with any extensions and features added on top o Lynx, such as JSON and file uploading.", 
            "title": "Puma"
        }, 
        {
            "location": "/puma/#a-single-requestresponse", 
            "text": "Puma is designed asynchronously, we only exposed the synchronous API so far.  A request is made the same way any of our requests are made  as described here.  You can then create an HTTP client:  // Creates a client for https://example.com\nlet response = SyncHTTPClient.send(request, toHost:  example.com , securely: true)", 
            "title": "A single request/response"
        }, 
        {
            "location": "/leopard/Multipart/", 
            "text": "Multipart\n\n\nMultipart is used for uploading complex forms, for example, those containing files.\n\n\nCreating a multipart form (HTML)\n\n\nForms require the addition of the \"enctype\" as displayed below.\n\n\nform method=\npost\n action=\n/path/to/handler\n enctype=\nmultipart/form-data\n\n  Favourite food: \ninput type=\ntext\n name=\nfavouriteFood\n /\nbr /\n\n  File upload: \ninput type=\nfile\n /\n\n  \nbutton\nSend\n/button\n\n\n/form\n\n\n\n\n\nParsing a request's multipart\n\n\nWe don't parse anything it until it's necessary, including Multipart.\n\n\nguard let multipart = request.multipart else {\n  ...\n}\n\n\n\n\nAccessing named parts\n\n\nIn the above HTML form, the text input box had a 'name'.\nYou can use this name to easily access that part.\n\n\nguard let favouriteFood = multipart[\nfavouriteFood\n] else {\n\n}\n\n\n\n\nAccessing all parts\n\n\nUnnamed parts can also be accessed. Multipart has a \nparts\n variable where you can find all parts.\n\n\nfor part in multipart.parts {\n\n}\n\n\n\n\nEvery part has data and a type. The type can be either a value or a file.\n\n\nFiles carry their filename and MIME type with them.\n\n\nHandling the HTML form on the server\n\n\nwebserver.get(\n/path/to/handler\n) { request in\n  return Future {\n    // First, the multipart needs to be parsed\n    guard let multipart = request.multipart else {\n      return Response(status: 400)\n    }\n\n    // Food has a 'name', thus it's easily accessible\n    guard let food = multipart[\nfavouriteFood\n]?.string else {\n      return Response(status: 400)\n    }\n\n    // the file doesn't have a name, let's handle all files\n    for part in multipart.parts {\n      // if it's not a file, continue the loop\n      guard case .file(let mime, let filename) = part.type else {\n        continue\n      }\n\n      // The binary blob, or, contents of the file\n      let body = try part.data.makeBody()\n\n      // TODO: process file\n    }\n  }\n}", 
            "title": "Forms and file uploading"
        }, 
        {
            "location": "/leopard/Multipart/#multipart", 
            "text": "Multipart is used for uploading complex forms, for example, those containing files.", 
            "title": "Multipart"
        }, 
        {
            "location": "/leopard/Multipart/#creating-a-multipart-form-html", 
            "text": "Forms require the addition of the \"enctype\" as displayed below.  form method= post  action= /path/to/handler  enctype= multipart/form-data \n  Favourite food:  input type= text  name= favouriteFood  / br / \n  File upload:  input type= file  / \n   button Send /button  /form", 
            "title": "Creating a multipart form (HTML)"
        }, 
        {
            "location": "/leopard/Multipart/#parsing-a-requests-multipart", 
            "text": "We don't parse anything it until it's necessary, including Multipart.  guard let multipart = request.multipart else {\n  ...\n}", 
            "title": "Parsing a request's multipart"
        }, 
        {
            "location": "/leopard/Multipart/#accessing-named-parts", 
            "text": "In the above HTML form, the text input box had a 'name'.\nYou can use this name to easily access that part.  guard let favouriteFood = multipart[ favouriteFood ] else {\n\n}", 
            "title": "Accessing named parts"
        }, 
        {
            "location": "/leopard/Multipart/#accessing-all-parts", 
            "text": "Unnamed parts can also be accessed. Multipart has a  parts  variable where you can find all parts.  for part in multipart.parts {\n\n}  Every part has data and a type. The type can be either a value or a file.  Files carry their filename and MIME type with them.", 
            "title": "Accessing all parts"
        }, 
        {
            "location": "/leopard/Multipart/#handling-the-html-form-on-the-server", 
            "text": "webserver.get( /path/to/handler ) { request in\n  return Future {\n    // First, the multipart needs to be parsed\n    guard let multipart = request.multipart else {\n      return Response(status: 400)\n    }\n\n    // Food has a 'name', thus it's easily accessible\n    guard let food = multipart[ favouriteFood ]?.string else {\n      return Response(status: 400)\n    }\n\n    // the file doesn't have a name, let's handle all files\n    for part in multipart.parts {\n      // if it's not a file, continue the loop\n      guard case .file(let mime, let filename) = part.type else {\n        continue\n      }\n\n      // The binary blob, or, contents of the file\n      let body = try part.data.makeBody()\n\n      // TODO: process file\n    }\n  }\n}", 
            "title": "Handling the HTML form on the server"
        }, 
        {
            "location": "/leopard/cache/", 
            "text": "", 
            "title": "Caching"
        }, 
        {
            "location": "/cheetah/", 
            "text": "Cheetah (JSON)\n\n\nCheetah is a fast library JSON. It's designed to read and write to strings and bytes. It's designed to have a familiar API for OpenKitten users.\n\n\nCheetah supports all Swift platforms (macOS, Linux, iOS, watchOS and tvOS) using Swift 3.0, 3.1, 3.2 and 4.0.\n\n\nSPM - Package.swift\n\n\nWhen creating a project using \nswift package init --type=executable\n, you'll notice that a set of files and directories have appeared in the current directory. One of these files is \nPackage.swift\n, the project definition.\n\n\nSwift 4.0\n\n\nFor Swift 4.0, use the following syntax for adding a dependency.\n\n\n.package(url: \nhttps://github.com/OpenKitten/Cheetah.git\n, .revision(\nframework\n))\n\n\n\n\nAnd by adding \n\"Leopard\"\n to your target's dependencies.\n\n\n// swift-tools-version:4.0\n// The swift-tools-version declares the minimum version of Swift required to build this package.\n\nimport PackageDescription\n\nlet package = Package(\n    name: \nExample\n,\n    dependencies: [\n        .package(url: \nhttps://github.com/OpenKitten/Cheetah.git\n, .revision(\nframework\n)),\n    ],\n    targets: [\n        .target(\n            name: \nExample\n,\n            dependencies: [\nCheetah\n]),\n    ]\n)\n\n\n\n\nSwift 3.x\n\n\nFor Swift 3.x, use the following syntax for adding a dependency.\n\n\n.Package(url: \nhttps://github.com/OpenKitten/Cheetah.git\n, Version(2,0,0))\n\n\n\n\nCreating a JSON Object or Array\n\n\nSwift 3.1 or greater\n\n\nFor objects and arrays you can just use the literals.\n\n\nlet object: JSONObject = [\n  \nusername\n: \nJoannis\n,\n  \nage\n: 21,\n  \nadmin\n: true,\n  \nnumber\n: 6.28,\n  \npowersOfTwo\n: [0, 2, 4, 6, 8, 10, 12, 14, 16],\n  \nsubObject\n: [\n    \ntest\n: true,\n    \nsubSubObject\n: [\n      \ntest\n: true\n    ]\n  ]\n]\n\nlet array: JSONArray = [object, object, object]\n\n\n\n\nSwift 3.0\n\n\nFor Swift 3.0, literals need to be specified a bit more explicitly. They require explicit definition of the type of literal.\n\n\nlet object: JSONObject = [\n  \nusername\n: \nJoannis\n,\n  \nage\n: 21,\n  \nadmin\n: true,\n  \nnumber\n: 6.28,\n  \npowersOfTwo\n: [0, 2, 4, 6, 8, 10, 12, 14, 16] as JSONArray,\n  \nsubObject\n: [\n    \ntest\n: true,\n    \nsubSubObject\n: [\n      \ntest\n: true\n    ] as JSONObject\n  ] as JSONObject\n]\n\n\n\n\nWorking with objects\n\n\nObjects are accessed using subscripts. Extracting a specific type is done by that type's initializer.\n\n\nvar object = JSONObject()\n\nobject[\nusername\n] = \nJoannis\n\nobject[\nage\n] = 21\nobject[\nadmin\n] = true\nobject[\nnumber\n] = 8.28\n\nlet username = String(object[\nusername\n]) ?? \n\nlet age: Int? = Int(object[\nage\n])\nlet admin = Bool(object[\nadmin\n]) ?? false\nlet number: Double? = Double(object[\nnumber\n])\n\n\n\n\n(de-)serializing JSON\n\n\nYou can easily create a JSONObject or JSONArray from a buffer.\n\n\nlet object = try JSONObject(from: buffer)\nlet array = try JSONArray(from: buffer)\n\n\n\n\nThe buffer can be \n[UInt8]\n, \nData\n or \nString\n.\n\n\nSerializing is equally easy:\n\n\nlet objectBytes: [UInt8] = object.serialize()\nlet arrayBytes: [UInt8] = array.serialize()\n\nlet objectString: String = object.serializedString()\nlet arrayString: String = array.serializedString()\n\n\n\n\nDeserializing arrays\n\n\nSometimes you need an array of a specific type. \nJSONArray\n helps when the array contains generic JSON, but, sometimes you need an array of \nString\ns.\n\n\nIn this case, we recommend flatMapping the JSONArray using the String initializer like so:\n\n\nlet blogPost: JSONObject = [\n  \ntitle\n: \nHow to use Cheetah\n,\n  \ncontents\n: \n...\n,\n  \ntags\n: [\n    \ncheetah\n, \nswift\n, \njson\n, \ntutorial\n\n  ]\n]\n\nlet tags = JSONArray(blogPost[\ntags\n])?.flatMap(String.init)\n\n\n\n\nNested objects\n\n\nSwift 3.1 or greater\n\n\nAccessing nested types can be simply chained:\n\n\nobject[\nsubObject\n][\nsubSubObject\n][\ntest\n] = true\nlet test = Bool(object[\nsubObject\n][\nsubSubObject\n][\ntest\n])\n\n\n\n\nSwift 3.0\n\n\nSwift 3.0 doesn't allow us to add the chaining descibed above. Instead, you'll have to unwrap and chain the subscripts manually.\n\n\n// TODO: Describe after the API has been revised\n\n\n\n\nCodable\n\n\nCheetah supports Codable, meaning you can conform any struct or class to \nEncodable\n for serializing, \nDecodable\n for deserializing and \nCodable\n for both.\n\n\nThis requires at least Swift 3.2 or it's equivalent Swift 4.\n\n\nEncoding\n\n\nimport Cheetah\n\nstruct LoginResponse : Encodable {\n  let token: String\n  let success: Bool\n}\n\nlet response = LoginResponse(token: \nmy-t0k3n\n, success: true)\n\nlet jsonObject = try Cheetah.JSONEncoder().encode(response)\nprint(jsonObject.serializedString()) // prints `{\ntoken\n:\nmy-t0k3n\n,\nsuccess\n:true}`\n\n\n\n\nDecoding\n\n\nimport Cheetah\n\nstruct LoginRequest : Decodable {\n  let username: String\n  let password: String\n}\n\nlet request = try Cheetah.JSONDecoder().decode(LoginRequest.self, from: \n{\\\nusername\\\n:\\\ntest\\\n,\\\npassword\\\n:\\\nhunter2\\\n}\n)\n\nprint(request.username) // prints \ntest\n\nprint(request.password) // prints \nhunter2", 
            "title": "JSON using Cheetah"
        }, 
        {
            "location": "/cheetah/#cheetah-json", 
            "text": "Cheetah is a fast library JSON. It's designed to read and write to strings and bytes. It's designed to have a familiar API for OpenKitten users.  Cheetah supports all Swift platforms (macOS, Linux, iOS, watchOS and tvOS) using Swift 3.0, 3.1, 3.2 and 4.0.", 
            "title": "Cheetah (JSON)"
        }, 
        {
            "location": "/cheetah/#spm-packageswift", 
            "text": "When creating a project using  swift package init --type=executable , you'll notice that a set of files and directories have appeared in the current directory. One of these files is  Package.swift , the project definition.", 
            "title": "SPM - Package.swift"
        }, 
        {
            "location": "/cheetah/#swift-40", 
            "text": "For Swift 4.0, use the following syntax for adding a dependency.  .package(url:  https://github.com/OpenKitten/Cheetah.git , .revision( framework ))  And by adding  \"Leopard\"  to your target's dependencies.  // swift-tools-version:4.0\n// The swift-tools-version declares the minimum version of Swift required to build this package.\n\nimport PackageDescription\n\nlet package = Package(\n    name:  Example ,\n    dependencies: [\n        .package(url:  https://github.com/OpenKitten/Cheetah.git , .revision( framework )),\n    ],\n    targets: [\n        .target(\n            name:  Example ,\n            dependencies: [ Cheetah ]),\n    ]\n)", 
            "title": "Swift 4.0"
        }, 
        {
            "location": "/cheetah/#swift-3x", 
            "text": "For Swift 3.x, use the following syntax for adding a dependency.  .Package(url:  https://github.com/OpenKitten/Cheetah.git , Version(2,0,0))", 
            "title": "Swift 3.x"
        }, 
        {
            "location": "/cheetah/#creating-a-json-object-or-array", 
            "text": "", 
            "title": "Creating a JSON Object or Array"
        }, 
        {
            "location": "/cheetah/#swift-31-or-greater", 
            "text": "For objects and arrays you can just use the literals.  let object: JSONObject = [\n   username :  Joannis ,\n   age : 21,\n   admin : true,\n   number : 6.28,\n   powersOfTwo : [0, 2, 4, 6, 8, 10, 12, 14, 16],\n   subObject : [\n     test : true,\n     subSubObject : [\n       test : true\n    ]\n  ]\n]\n\nlet array: JSONArray = [object, object, object]", 
            "title": "Swift 3.1 or greater"
        }, 
        {
            "location": "/cheetah/#swift-30", 
            "text": "For Swift 3.0, literals need to be specified a bit more explicitly. They require explicit definition of the type of literal.  let object: JSONObject = [\n   username :  Joannis ,\n   age : 21,\n   admin : true,\n   number : 6.28,\n   powersOfTwo : [0, 2, 4, 6, 8, 10, 12, 14, 16] as JSONArray,\n   subObject : [\n     test : true,\n     subSubObject : [\n       test : true\n    ] as JSONObject\n  ] as JSONObject\n]", 
            "title": "Swift 3.0"
        }, 
        {
            "location": "/cheetah/#working-with-objects", 
            "text": "Objects are accessed using subscripts. Extracting a specific type is done by that type's initializer.  var object = JSONObject()\n\nobject[ username ] =  Joannis \nobject[ age ] = 21\nobject[ admin ] = true\nobject[ number ] = 8.28\n\nlet username = String(object[ username ]) ??  \nlet age: Int? = Int(object[ age ])\nlet admin = Bool(object[ admin ]) ?? false\nlet number: Double? = Double(object[ number ])", 
            "title": "Working with objects"
        }, 
        {
            "location": "/cheetah/#de-serializing-json", 
            "text": "You can easily create a JSONObject or JSONArray from a buffer.  let object = try JSONObject(from: buffer)\nlet array = try JSONArray(from: buffer)  The buffer can be  [UInt8] ,  Data  or  String .  Serializing is equally easy:  let objectBytes: [UInt8] = object.serialize()\nlet arrayBytes: [UInt8] = array.serialize()\n\nlet objectString: String = object.serializedString()\nlet arrayString: String = array.serializedString()", 
            "title": "(de-)serializing JSON"
        }, 
        {
            "location": "/cheetah/#deserializing-arrays", 
            "text": "Sometimes you need an array of a specific type.  JSONArray  helps when the array contains generic JSON, but, sometimes you need an array of  String s.  In this case, we recommend flatMapping the JSONArray using the String initializer like so:  let blogPost: JSONObject = [\n   title :  How to use Cheetah ,\n   contents :  ... ,\n   tags : [\n     cheetah ,  swift ,  json ,  tutorial \n  ]\n]\n\nlet tags = JSONArray(blogPost[ tags ])?.flatMap(String.init)", 
            "title": "Deserializing arrays"
        }, 
        {
            "location": "/cheetah/#nested-objects", 
            "text": "", 
            "title": "Nested objects"
        }, 
        {
            "location": "/cheetah/#swift-31-or-greater_1", 
            "text": "Accessing nested types can be simply chained:  object[ subObject ][ subSubObject ][ test ] = true\nlet test = Bool(object[ subObject ][ subSubObject ][ test ])", 
            "title": "Swift 3.1 or greater"
        }, 
        {
            "location": "/cheetah/#swift-30_1", 
            "text": "Swift 3.0 doesn't allow us to add the chaining descibed above. Instead, you'll have to unwrap and chain the subscripts manually.  // TODO: Describe after the API has been revised", 
            "title": "Swift 3.0"
        }, 
        {
            "location": "/cheetah/#codable", 
            "text": "Cheetah supports Codable, meaning you can conform any struct or class to  Encodable  for serializing,  Decodable  for deserializing and  Codable  for both.  This requires at least Swift 3.2 or it's equivalent Swift 4.", 
            "title": "Codable"
        }, 
        {
            "location": "/cheetah/#encoding", 
            "text": "import Cheetah\n\nstruct LoginResponse : Encodable {\n  let token: String\n  let success: Bool\n}\n\nlet response = LoginResponse(token:  my-t0k3n , success: true)\n\nlet jsonObject = try Cheetah.JSONEncoder().encode(response)\nprint(jsonObject.serializedString()) // prints `{ token : my-t0k3n , success :true}`", 
            "title": "Encoding"
        }, 
        {
            "location": "/cheetah/#decoding", 
            "text": "import Cheetah\n\nstruct LoginRequest : Decodable {\n  let username: String\n  let password: String\n}\n\nlet request = try Cheetah.JSONDecoder().decode(LoginRequest.self, from:  {\\ username\\ :\\ test\\ ,\\ password\\ :\\ hunter2\\ } )\n\nprint(request.username) // prints  test \nprint(request.password) // prints  hunter2", 
            "title": "Decoding"
        }, 
        {
            "location": "/schrodinger/", 
            "text": "Schrodinger\n\n\nSchrodinger is a library built for asynchronous programming. It works around a couple of simple concepts.\n\n\nIt can be included using:\n\n\n.package(url: \nhttps://github.com/OpenKitten/Schrodinger.git\n, .exact(\n1.0.0-beta1\n)),\n\n\n\n\nExamples\n\n\nHeavy operations on a separate thread\n\n\nThe following Future spawns a separate thread that handles these heavy operations.\n\n\nThe resulting future is a \nFuture\nVoid\n since there's no value being returned from the closure.\n\n\nWhenever you need to wait for the completion of the future, you can \n.await()\n it. Awaiting a future means you block the thread until it's complete.\n\n\nAwait will throw an error when the wait time has expired or if the executed closure had an error while executing. It will re-throw the captured error.\n\n\nlet future = Future {\n  heavyOperation0()\n  heavyOperation1()\n  heavyOperation2()\n}\n\nlightOperation0()\nlightOperation1()\nlightOperation2()\nlightOperation3()\n\n// We need the heavy operations to be complete before continuing\n// Throws an error if this doesn't complete in 30 seconds\ntry future.await(for: .seconds(30))\n\n\n\n\nWorking with value containing futures\n\n\nMore often than not, you need to pass a result from the operation. This means that awaiting the value will return the returned value. Any errors thrown within the future\n\n\n// This future will contain a string\nlet future = Future\nString\n {\n  return try heavyOperationWithResult()\n}\n\nlightOperation0()\nlightOperation1()\nlightOperation2()\nlightOperation3()\n\nlet heavyOperationResult = try future.await(for: .seconds(10))\n\n\n\n\nHandling futures asynchronously\n\n\nSometimes, awaiting the thread is unnecessary and an asynchronous handler can be used instead.\n\n\nlet future: Future\n[User]\n = try findUsersAsync()\n\nfuture.onSuccess { users in\n  // process the `[User]` (users)\n  ...\n}\n\nfuture.onError { error in\n  // handle error\n  // for example `Application.logger?.log(error)` in Leopard\n}\n\n\n\n\nIf you want more fine-grained control over both situations you can place a handler on both successful completions and errors.\n\n\nlet future: Future\n[User]\n = try findUsersAsync()\n\n// result contains an enum\nfuture.then { result in\n  switch result {\n  case .success(let users):\n    // TODO: process users\n  case .error(let error):\n    // TODO: handle error\n  }\n}\n\n\n\n\nSometimes you want to assert the success of a result, that will let Schrodinger throw the error if an error occurred, or give you the successful result if the result was captured successfully.\n\n\nlet future: Future\n[User]\n = try findUsersAsync()\n\n// result contains an enum\nfuture.then { result in\n  do {\n    let users = try result.assertSuccess()\n\n    // TODO: handle users\n  } catch { error in\n    // handle error\n    // for example `Application.logger?.log(error)` in Leopard\n  }\n}\n\n\n\n\nMultiple handlers\n\n\nSometimes you'll want to watch for a result using multiple handlers. For example, a chat room with 5 users. One user sends a message and the other 4 await it's result.\n\n\nThat means the following is completely fine:\n\n\nlet future: Future\nChatMessage\n = awaitForChatMessage()\n\n// first handler\nfuture.then { result in\n  ...\n}\n\n// second handler\nfuture.then { result in\n  ...\n}\n\n// third handler\nfuture.then { result in\n  ...\n}\n\n// fourth handler\nfuture.then { result in\n  ...\n}\n\n\n\n\nFuture mapping and replacing\n\n\nWhenever you're working asynchronously, awaiting a result alone can fall too short.\n\n\nSometimes you'll need to convert the result. Like a database result conversion to a model.\n\n\nFor this case, future mapping is useful.\n\n\nlet future: Future\nDatabaseData\n = try database.fetch(from: \nusers\n)\n\n// maps the future asynchronously\nlet model: Future\nModel\n = try future.map { data in\n  return try MyModel(from: data)\n}\n\n\n\n\nAnd in some scenarios, completing one future means starting another.\n\n\nThe following code results in a code pyramid:\n\n\nlet future: Future\nDatabaseData\n = try database.fetch(from: \nusers\n)\n\n// maps the future asynchronously\nlet model: Future\nFuture\nProfileModel\n = try future.map { data in\n  let model = try UserModel(from: data)\n\n  let profile = Future\nProfileModel\n = try model.getProfile()\n\n  return profile\n}\n\n// NOTE: `until: DispatchTime.distantFuture` waits indefinitely\nlet profile = try model.await(until: DispatchTime.distantFuture).await(until: DispatchTime.distantFuture)\n\n\n\n\nWhich can be simplified using \nreplace\n.\n\n\nlet future: Future\nDatabaseData\n = try database.fetch(from: \nusers\n)\n\n// maps the future asynchronously\nlet model: Future\nProfileModel\n = try future.replace { data in\n  let model = try UserModel(from: data)\n\n  let profile = Future\nProfileModel\n = try model.getProfile()\n\n  return profile\n}\n\nlet profile = try model.await(until: DispatchTime.distantFuture)", 
            "title": "Async using Schrodinger"
        }, 
        {
            "location": "/schrodinger/#schrodinger", 
            "text": "Schrodinger is a library built for asynchronous programming. It works around a couple of simple concepts.  It can be included using:  .package(url:  https://github.com/OpenKitten/Schrodinger.git , .exact( 1.0.0-beta1 )),", 
            "title": "Schrodinger"
        }, 
        {
            "location": "/schrodinger/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/schrodinger/#heavy-operations-on-a-separate-thread", 
            "text": "The following Future spawns a separate thread that handles these heavy operations.  The resulting future is a  Future Void  since there's no value being returned from the closure.  Whenever you need to wait for the completion of the future, you can  .await()  it. Awaiting a future means you block the thread until it's complete.  Await will throw an error when the wait time has expired or if the executed closure had an error while executing. It will re-throw the captured error.  let future = Future {\n  heavyOperation0()\n  heavyOperation1()\n  heavyOperation2()\n}\n\nlightOperation0()\nlightOperation1()\nlightOperation2()\nlightOperation3()\n\n// We need the heavy operations to be complete before continuing\n// Throws an error if this doesn't complete in 30 seconds\ntry future.await(for: .seconds(30))", 
            "title": "Heavy operations on a separate thread"
        }, 
        {
            "location": "/schrodinger/#working-with-value-containing-futures", 
            "text": "More often than not, you need to pass a result from the operation. This means that awaiting the value will return the returned value. Any errors thrown within the future  // This future will contain a string\nlet future = Future String  {\n  return try heavyOperationWithResult()\n}\n\nlightOperation0()\nlightOperation1()\nlightOperation2()\nlightOperation3()\n\nlet heavyOperationResult = try future.await(for: .seconds(10))", 
            "title": "Working with value containing futures"
        }, 
        {
            "location": "/schrodinger/#handling-futures-asynchronously", 
            "text": "Sometimes, awaiting the thread is unnecessary and an asynchronous handler can be used instead.  let future: Future [User]  = try findUsersAsync()\n\nfuture.onSuccess { users in\n  // process the `[User]` (users)\n  ...\n}\n\nfuture.onError { error in\n  // handle error\n  // for example `Application.logger?.log(error)` in Leopard\n}  If you want more fine-grained control over both situations you can place a handler on both successful completions and errors.  let future: Future [User]  = try findUsersAsync()\n\n// result contains an enum\nfuture.then { result in\n  switch result {\n  case .success(let users):\n    // TODO: process users\n  case .error(let error):\n    // TODO: handle error\n  }\n}  Sometimes you want to assert the success of a result, that will let Schrodinger throw the error if an error occurred, or give you the successful result if the result was captured successfully.  let future: Future [User]  = try findUsersAsync()\n\n// result contains an enum\nfuture.then { result in\n  do {\n    let users = try result.assertSuccess()\n\n    // TODO: handle users\n  } catch { error in\n    // handle error\n    // for example `Application.logger?.log(error)` in Leopard\n  }\n}", 
            "title": "Handling futures asynchronously"
        }, 
        {
            "location": "/schrodinger/#multiple-handlers", 
            "text": "Sometimes you'll want to watch for a result using multiple handlers. For example, a chat room with 5 users. One user sends a message and the other 4 await it's result.  That means the following is completely fine:  let future: Future ChatMessage  = awaitForChatMessage()\n\n// first handler\nfuture.then { result in\n  ...\n}\n\n// second handler\nfuture.then { result in\n  ...\n}\n\n// third handler\nfuture.then { result in\n  ...\n}\n\n// fourth handler\nfuture.then { result in\n  ...\n}", 
            "title": "Multiple handlers"
        }, 
        {
            "location": "/schrodinger/#future-mapping-and-replacing", 
            "text": "Whenever you're working asynchronously, awaiting a result alone can fall too short.  Sometimes you'll need to convert the result. Like a database result conversion to a model.  For this case, future mapping is useful.  let future: Future DatabaseData  = try database.fetch(from:  users )\n\n// maps the future asynchronously\nlet model: Future Model  = try future.map { data in\n  return try MyModel(from: data)\n}  And in some scenarios, completing one future means starting another.  The following code results in a code pyramid:  let future: Future DatabaseData  = try database.fetch(from:  users )\n\n// maps the future asynchronously\nlet model: Future Future ProfileModel  = try future.map { data in\n  let model = try UserModel(from: data)\n\n  let profile = Future ProfileModel  = try model.getProfile()\n\n  return profile\n}\n\n// NOTE: `until: DispatchTime.distantFuture` waits indefinitely\nlet profile = try model.await(until: DispatchTime.distantFuture).await(until: DispatchTime.distantFuture)  Which can be simplified using  replace .  let future: Future DatabaseData  = try database.fetch(from:  users )\n\n// maps the future asynchronously\nlet model: Future ProfileModel  = try future.replace { data in\n  let model = try UserModel(from: data)\n\n  let profile = Future ProfileModel  = try model.getProfile()\n\n  return profile\n}\n\nlet profile = try model.await(until: DispatchTime.distantFuture)", 
            "title": "Future mapping and replacing"
        }, 
        {
            "location": "/lynx/", 
            "text": "Lynx\n\n\nLynx is a very basic HTTP server. It, optionally, has some basic routing functionality and by default routes all request to a single handler so it can be used in any way without enforcing limitations.\n\n\nCreating a webserver\n\n\nCreating a basic webserver is simple. You provide a closure that handles all requests and clients.\n\n\nThe handler may not throw errors. Instead, errors should be passed to the client.\n\n\nlet server = try HTTPServer { request, client in\n  // handle the request and respond to the client\n}\n\n\n\n\nWhen ready, you can start the server using \nstart()\n\n\ntry server.start()\n\n\n\n\nRouting\n\n\nlet router = TrieRouter()\n\n\n\n\nThe router can be hooked up to a webserver simply.\n\n\nlet server = try HTTPServer(handler: router.handle)\n\n\n\n\nRegistering routes should only be done during set up. I \ncan\n be used while serving, however, it \nmay\n crash the server if a request is being handled during the addition of a route. A custom router can with a lock can be used to solve this problem.\n\n\nRegistering a route\n\n\n// Registers to `GET /path/to/route`\nrouter.register(at: [\npath\n, \nto\n, \nroute\n], method: .get) { request, client in\n  // handle the request and respond to the client\n}\n\n\n\n\nResponding\n\n\nlet response = Response(status: .ok)\n\ndo {\n  try client.send(response)\n} catch {\n  client.error(error)\n}\n\n\n\n\nOther information\n\n\nHTTP Request and responses\n is a useful place to learn more about the two main objects in HTTP.\n\n\nLynx does not support basic web framework features, it is designed to be simple.", 
            "title": "Plain HTTP using Lynx"
        }, 
        {
            "location": "/lynx/#lynx", 
            "text": "Lynx is a very basic HTTP server. It, optionally, has some basic routing functionality and by default routes all request to a single handler so it can be used in any way without enforcing limitations.", 
            "title": "Lynx"
        }, 
        {
            "location": "/lynx/#creating-a-webserver", 
            "text": "Creating a basic webserver is simple. You provide a closure that handles all requests and clients.  The handler may not throw errors. Instead, errors should be passed to the client.  let server = try HTTPServer { request, client in\n  // handle the request and respond to the client\n}  When ready, you can start the server using  start()  try server.start()", 
            "title": "Creating a webserver"
        }, 
        {
            "location": "/lynx/#routing", 
            "text": "let router = TrieRouter()  The router can be hooked up to a webserver simply.  let server = try HTTPServer(handler: router.handle)  Registering routes should only be done during set up. I  can  be used while serving, however, it  may  crash the server if a request is being handled during the addition of a route. A custom router can with a lock can be used to solve this problem.", 
            "title": "Routing"
        }, 
        {
            "location": "/lynx/#registering-a-route", 
            "text": "// Registers to `GET /path/to/route`\nrouter.register(at: [ path ,  to ,  route ], method: .get) { request, client in\n  // handle the request and respond to the client\n}", 
            "title": "Registering a route"
        }, 
        {
            "location": "/lynx/#responding", 
            "text": "let response = Response(status: .ok)\n\ndo {\n  try client.send(response)\n} catch {\n  client.error(error)\n}", 
            "title": "Responding"
        }, 
        {
            "location": "/lynx/#other-information", 
            "text": "HTTP Request and responses  is a useful place to learn more about the two main objects in HTTP.  Lynx does not support basic web framework features, it is designed to be simple.", 
            "title": "Other information"
        }, 
        {
            "location": "/ocelot/", 
            "text": "Ocelot\n\n\nOcelot is a \nCheetah\n based JWT implementation. It only covers JWS (JSON Web Signature), meaning all tokens are \nsigned, not encrypted\n.\n\n\nAny data in the JWT is readable but not writable by the client.\n\n\nSPM\n\n\nOcelot requires Swift 4 and the following dependency to be added:\n\n\n.package(url: \nhttps://github.com/OpenKitten/Cheetah.git\n, from: \n2.0.0\n)\n\n\n\n\nCreating a JSON Web Token\n\n\nCreating a token is as simple as creating a \nstruct\n and making it \nCodable\n.\n\n\nstruct AuthenticationToken : Codable {\n  var username: String\n}\n\n\n\n\nOnce you create an instance of this token, you can sign it using \nJWSEncoder\n. You'll need a (globally) defined secret in order to sign this JWT.\n\n\nPlease choose a random, high entropy, high amount of characters string for encoding the token.\n\n\nimport Ocelot\n\n// Random, secure, private\n// May not be known to anyone else\nlet secret = \nDOn0tus3th1sPL3453\n\n\n// Create a new instance of the above codable token struct\nlet token = AuthenticationToken(username: \nJoannisO\n)\n\n// Signed using HMAC SHA512 and the above secret\nlet signedToken = try JWSEncoder.sign(token, signedBy: secret, using: .hs512())\n\n\n\n\nThe \nsignedToken\n can then be given to the user, who can then carry this in a authorization bearer header, cookie or any other method you prefer for receiving the token.\n\n\nDeserializing the JSON Web Token to a struct\n\n\nJWSDecoder\n can take the above \nsignedToken\n and restore it back to a type-safe \nstruct\n.\n\n\n// Verifies the token, too, using the secet. If the token is invalid, an error will be thrown\nlet token = try JWSDecoder.decode(AuthenticationToken.self, from: signedToken, verifying: secret)\n\nlet works = token.username == \nJoannisO\n // true", 
            "title": "JWT using Ocelot"
        }, 
        {
            "location": "/ocelot/#ocelot", 
            "text": "Ocelot is a  Cheetah  based JWT implementation. It only covers JWS (JSON Web Signature), meaning all tokens are  signed, not encrypted .  Any data in the JWT is readable but not writable by the client.", 
            "title": "Ocelot"
        }, 
        {
            "location": "/ocelot/#spm", 
            "text": "Ocelot requires Swift 4 and the following dependency to be added:  .package(url:  https://github.com/OpenKitten/Cheetah.git , from:  2.0.0 )", 
            "title": "SPM"
        }, 
        {
            "location": "/ocelot/#creating-a-json-web-token", 
            "text": "Creating a token is as simple as creating a  struct  and making it  Codable .  struct AuthenticationToken : Codable {\n  var username: String\n}  Once you create an instance of this token, you can sign it using  JWSEncoder . You'll need a (globally) defined secret in order to sign this JWT.  Please choose a random, high entropy, high amount of characters string for encoding the token.  import Ocelot\n\n// Random, secure, private\n// May not be known to anyone else\nlet secret =  DOn0tus3th1sPL3453 \n\n// Create a new instance of the above codable token struct\nlet token = AuthenticationToken(username:  JoannisO )\n\n// Signed using HMAC SHA512 and the above secret\nlet signedToken = try JWSEncoder.sign(token, signedBy: secret, using: .hs512())  The  signedToken  can then be given to the user, who can then carry this in a authorization bearer header, cookie or any other method you prefer for receiving the token.", 
            "title": "Creating a JSON Web Token"
        }, 
        {
            "location": "/ocelot/#deserializing-the-json-web-token-to-a-struct", 
            "text": "JWSDecoder  can take the above  signedToken  and restore it back to a type-safe  struct .  // Verifies the token, too, using the secet. If the token is invalid, an error will be thrown\nlet token = try JWSDecoder.decode(AuthenticationToken.self, from: signedToken, verifying: secret)\n\nlet works = token.username ==  JoannisO  // true", 
            "title": "Deserializing the JSON Web Token to a struct"
        }, 
        {
            "location": "/cryptokitten/hash/", 
            "text": "Hashing\n\n\nHashing is the process of one-way encryption. It's an encryption that can't be reverted.\n\n\nThis is particularly useful for verifying information. One way hashes are employed is by hashing a message and verifying the message to output the same resulting hash on arrival. If the hash and/or message were tampered with or have been modified during transport, the results of hashing the file would not result in the same hash, making the information invalid.\n\n\nThe same is used for password hashing. The original password is not important, it poses a security risk on the user in case of data theft, for example, on a security breach of the information system (like a website).\n\n\nHeavily and securely hashing a password is necessary to prevent brute forces.\n\n\nSupport\n\n\nCryptoKitten currently supports the following hashes:\n\n\n\n\nMD5\n\n\nSHA1\n\n\nSHA224\n\n\nSHA256\n\n\nSHA384\n\n\nSHA512\n\n\n\n\nIt also supports HMAC and PBKDF2 for message authentication and password hashing.\n\n\nUsing a hash\n\n\nAll of the hashes described above have the same API and support two methods of hashing.\n\n\n'Bulk' hashing\n\n\nHashing the entire message in one go is simple and natural, it doesn't require extra work. You'll need to enter the data as binary. This means Strings also need to be converted to binary. A common method of converting a string to binary is this:\n\n\nlet binaryMessage = [UInt8](binaryMessage.utf8)\n\n\n\n\nTo bulk hash binary data:\n\n\nlet hashedMessage0 = MD5.hash(binaryMessage)\nlet hashedMessage1 = SHA1.hash(binaryMessage)\nlet hashedMessage2 = SHA224.hash(binaryMessage)\nlet hashedMessage3 = SHA256.hash(binaryMessage)\nlet hashedMessage4 = SHA384.hash(binaryMessage)\nlet hashedMessage5 = SHA512.hash(binaryMessage)\n\n\n\n\nDo \nnot\n use basic hashes for passwords. They will be easily \nbrute-forced\n.\n\n\nIncremental\n\n\nLarger messages need to be copied around a lot. In a 1GB video, it means copying around 1GB of data. This makes the process unnecessarily really heavy. Instead of hashing the whole 1GB in one go, which would cost 2-3GB, you could pass around the buffer, for example, as a pointer.\n\n\nWhen working with streams of incoming/outgoing data, you can also stream the data chunk by chunk to the hashing algorithm.\n\n\nBefore getting the hash, you'll need to finalize the hash, which will finish calculating the hash. This is \nrequired\n. Once you know the final block, you can pass it to finalize entirely.\n\n\n// Create the context first\nlet context = MD5()\n\nfor fileData in file {\n  context.update(fileData)\n}\n\n// The data to hash\nlet lastBlock: UnsafeBufferPointer\nUInt8\n = ...\n\n// Hash the block of data\ncontext.finalize(fileData)\n\n// the hash as hexadecimal\nlet hash = context.hash.hexString\n\n\n\n\nIf the final block is already hashed, you still need to finalize it by calling finalize, even if there's an empty buffer of data to hash.\n\n\nPassword hashing\n\n\nFor password hashing we currently only support PBKDF2 with HMAC.\n\n\nPBKDF2_HMAC\n\n\nHashing a password using PBKDF2 requires a hashing algorithm. You can select one generically like this:\n\n\n// with MD5\nPBKDF2_HMAC\nMD5\n\n\n// with SHA1\nPBKDF2_HMAC\nSHA1\n\n\n// with SHA512\nPBKDF2_HMAC\nSHA512\n\n\n\n\n\nYou can derive a key from the PBKDF2_HMAC. This requires three parameters.\n\n\nThe password is needed in binary. You can get the binary data from a string like below:\n\n\nlet binaryPassword = [UInt8](password.utf8)\n\n\n\n\nAdditionally, a \nrandom\n salt is needed. This salt \nmust\n be randomly generated, \nmust\n not be static and \nmust\n be stored with the password in the database. Losing the salt means it's impossible to validate the stored (encrypted) password.\n\n\nlet hash = PBKDF2_HMAC\nSHA512\n.derive(fromPassword: binaryPassword, saltedWith: randomSalt).hexString\n\n\n\n\nTo validate it you can repeat the process.\n\n\nlet verifiedHash = PBKDF2_HMAC\nSHA512\n.derive(fromPassword: binaryPassword, saltedWith: randomSalt).hexString\n\nlet passwordCorrect = (hash == verifiedHash)", 
            "title": "Hashing using CryptoKitten"
        }, 
        {
            "location": "/cryptokitten/hash/#hashing", 
            "text": "Hashing is the process of one-way encryption. It's an encryption that can't be reverted.  This is particularly useful for verifying information. One way hashes are employed is by hashing a message and verifying the message to output the same resulting hash on arrival. If the hash and/or message were tampered with or have been modified during transport, the results of hashing the file would not result in the same hash, making the information invalid.  The same is used for password hashing. The original password is not important, it poses a security risk on the user in case of data theft, for example, on a security breach of the information system (like a website).  Heavily and securely hashing a password is necessary to prevent brute forces.", 
            "title": "Hashing"
        }, 
        {
            "location": "/cryptokitten/hash/#support", 
            "text": "CryptoKitten currently supports the following hashes:   MD5  SHA1  SHA224  SHA256  SHA384  SHA512   It also supports HMAC and PBKDF2 for message authentication and password hashing.", 
            "title": "Support"
        }, 
        {
            "location": "/cryptokitten/hash/#using-a-hash", 
            "text": "All of the hashes described above have the same API and support two methods of hashing.", 
            "title": "Using a hash"
        }, 
        {
            "location": "/cryptokitten/hash/#bulk-hashing", 
            "text": "Hashing the entire message in one go is simple and natural, it doesn't require extra work. You'll need to enter the data as binary. This means Strings also need to be converted to binary. A common method of converting a string to binary is this:  let binaryMessage = [UInt8](binaryMessage.utf8)  To bulk hash binary data:  let hashedMessage0 = MD5.hash(binaryMessage)\nlet hashedMessage1 = SHA1.hash(binaryMessage)\nlet hashedMessage2 = SHA224.hash(binaryMessage)\nlet hashedMessage3 = SHA256.hash(binaryMessage)\nlet hashedMessage4 = SHA384.hash(binaryMessage)\nlet hashedMessage5 = SHA512.hash(binaryMessage)  Do  not  use basic hashes for passwords. They will be easily  brute-forced .", 
            "title": "'Bulk' hashing"
        }, 
        {
            "location": "/cryptokitten/hash/#incremental", 
            "text": "Larger messages need to be copied around a lot. In a 1GB video, it means copying around 1GB of data. This makes the process unnecessarily really heavy. Instead of hashing the whole 1GB in one go, which would cost 2-3GB, you could pass around the buffer, for example, as a pointer.  When working with streams of incoming/outgoing data, you can also stream the data chunk by chunk to the hashing algorithm.  Before getting the hash, you'll need to finalize the hash, which will finish calculating the hash. This is  required . Once you know the final block, you can pass it to finalize entirely.  // Create the context first\nlet context = MD5()\n\nfor fileData in file {\n  context.update(fileData)\n}\n\n// The data to hash\nlet lastBlock: UnsafeBufferPointer UInt8  = ...\n\n// Hash the block of data\ncontext.finalize(fileData)\n\n// the hash as hexadecimal\nlet hash = context.hash.hexString  If the final block is already hashed, you still need to finalize it by calling finalize, even if there's an empty buffer of data to hash.", 
            "title": "Incremental"
        }, 
        {
            "location": "/cryptokitten/hash/#password-hashing", 
            "text": "For password hashing we currently only support PBKDF2 with HMAC.", 
            "title": "Password hashing"
        }, 
        {
            "location": "/cryptokitten/hash/#pbkdf2_hmac", 
            "text": "Hashing a password using PBKDF2 requires a hashing algorithm. You can select one generically like this:  // with MD5\nPBKDF2_HMAC MD5 \n\n// with SHA1\nPBKDF2_HMAC SHA1 \n\n// with SHA512\nPBKDF2_HMAC SHA512   You can derive a key from the PBKDF2_HMAC. This requires three parameters.  The password is needed in binary. You can get the binary data from a string like below:  let binaryPassword = [UInt8](password.utf8)  Additionally, a  random  salt is needed. This salt  must  be randomly generated,  must  not be static and  must  be stored with the password in the database. Losing the salt means it's impossible to validate the stored (encrypted) password.  let hash = PBKDF2_HMAC SHA512 .derive(fromPassword: binaryPassword, saltedWith: randomSalt).hexString  To validate it you can repeat the process.  let verifiedHash = PBKDF2_HMAC SHA512 .derive(fromPassword: binaryPassword, saltedWith: randomSalt).hexString\n\nlet passwordCorrect = (hash == verifiedHash)", 
            "title": "PBKDF2_HMAC"
        }, 
        {
            "location": "/lynx/TCP/", 
            "text": "TCP\n\n\nLynx also handles the implementation of the TCP sockets. This supports clients sockets with and without SSL.\n\n\nThis makes Lynx a solid basis for common web libraries, since many principles (such as MIME, headers, body and Multipart) are reused.\n\n\nClient\n\n\nThe plain and SSL TCP clients are almost identical in their API.\n\n\nPlain Client\n\n\nOpening a simple socket using \nTCPClient\n is done by providing a hostname and port.\n\n\n// Sets up the connection\nlet exampleClient = try TCPClient(hostname: \nexample.com\n, port: 127) { pointer, length in\n  // process input\n}\n\n// Starts the connection, allowing read/write operations\nexampleClient.connect()\n\n\n\n\nThe connection cleans up on deinitialization, meaning you don't need to close it manually.\n\n\nSSL Client\n\n\nSSLClients are opened and used the same was as a \nTCPClient\n. SSLClient will use the Security framework on macOS, and OpenSSL on Linux.\n\n\n// Sets up the connection\nlet exampleSSLClient = try TCPSSLClient(hostname: \nexample.com\n, port: 127) { pointer, length in\n  // process input\n}\n\n// Starts the connection, allowing read/write operations\nexampleSSLClient.connect()\n\n\n\n\nReceiving data\n\n\nThe trailing closure behind the \nTCPClient\n or \nTCPSSLClient\n is the on-read function. Since the sockets are built entirely in async, as our libraries do, input needs to be processed in the closure.\n\n\nSending data\n\n\nWe currently accept 3 forms of sending data, which all boil down to the same.\n\n\nlet pointer: UnsafePointer\nUInt8\n\nlet length: Int\n\ntry client.send(data: pointer, withLengthOf: length)\n\n\n\n\nlet buffer: UnsafeBufferPointer\nUInt8\n\n\ntry client.send(buffer: buffer)\n\n\n\n\nlet bytes: [UInt8]\n\ntry client.send(bytes)", 
            "title": "TCP/SSL using Lynx"
        }, 
        {
            "location": "/lynx/TCP/#tcp", 
            "text": "Lynx also handles the implementation of the TCP sockets. This supports clients sockets with and without SSL.  This makes Lynx a solid basis for common web libraries, since many principles (such as MIME, headers, body and Multipart) are reused.", 
            "title": "TCP"
        }, 
        {
            "location": "/lynx/TCP/#client", 
            "text": "The plain and SSL TCP clients are almost identical in their API.", 
            "title": "Client"
        }, 
        {
            "location": "/lynx/TCP/#plain-client", 
            "text": "Opening a simple socket using  TCPClient  is done by providing a hostname and port.  // Sets up the connection\nlet exampleClient = try TCPClient(hostname:  example.com , port: 127) { pointer, length in\n  // process input\n}\n\n// Starts the connection, allowing read/write operations\nexampleClient.connect()  The connection cleans up on deinitialization, meaning you don't need to close it manually.", 
            "title": "Plain Client"
        }, 
        {
            "location": "/lynx/TCP/#ssl-client", 
            "text": "SSLClients are opened and used the same was as a  TCPClient . SSLClient will use the Security framework on macOS, and OpenSSL on Linux.  // Sets up the connection\nlet exampleSSLClient = try TCPSSLClient(hostname:  example.com , port: 127) { pointer, length in\n  // process input\n}\n\n// Starts the connection, allowing read/write operations\nexampleSSLClient.connect()", 
            "title": "SSL Client"
        }, 
        {
            "location": "/lynx/TCP/#receiving-data", 
            "text": "The trailing closure behind the  TCPClient  or  TCPSSLClient  is the on-read function. Since the sockets are built entirely in async, as our libraries do, input needs to be processed in the closure.", 
            "title": "Receiving data"
        }, 
        {
            "location": "/lynx/TCP/#sending-data", 
            "text": "We currently accept 3 forms of sending data, which all boil down to the same.  let pointer: UnsafePointer UInt8 \nlet length: Int\n\ntry client.send(data: pointer, withLengthOf: length)  let buffer: UnsafeBufferPointer UInt8 \n\ntry client.send(buffer: buffer)  let bytes: [UInt8]\n\ntry client.send(bytes)", 
            "title": "Sending data"
        }, 
        {
            "location": "/lynx/remote/", 
            "text": "HTTPRemote\n\n\nHTTPRemote is a protocol that handles HTTP Responses. It can be implemented using a custom implementation to levarage testability.\n\n\nClient\n\n\nClient is the default remote TCP Client implementation. It handles serialization of responses and has an extension point for error handling.\n\n\nError handling\n\n\nClient.errorHandler\n is a variable that can be assigned a closure that handles errors that are \nEncodable\n. This is especially useful for responding to the Client with a JSON serialized Error.\n\n\nFor example:\n\n\n// HTTP\nimport Lynx\n\n// JSON\nimport Cheetah\n\nClient.errorHandler = { error, client in\n  dp {\n    // Attempt to encode the error\n    let jsonError = JSONEncoder().encode(error)\n    let response = Response(status: 500, body: jsonError)\n\n    // Send the error\n    try client.send(response)\n\n    // Close the connection\n    client.close()\n  } catch {\n    // If the above failed, just close the connection\n    client.close()\n  }\n}\n\n\n\n\nTestClient\n\n\nTestClient is primarily useful in unit tests.\n\n\nIt accepts both an successful response and error handler\n\n\nlet client = TestClient({ response in\n  XCTAssertEqual(response.status.code, 200)\n}, or: { error in\n  XCTFail(\n\\(error)\n)\n})\n\n\n\n\nWhen you've created a testClient, you can pass it together with a request directly in the router or HTTP server.\n\n\nlet request = Request(method: .get, path: \n/\n)\n\n// Only need one of these 2\nrouter.handle(request, for: client)\nserver.handle(request, for: client)", 
            "title": "Testing remotes using Lynx"
        }, 
        {
            "location": "/lynx/remote/#httpremote", 
            "text": "HTTPRemote is a protocol that handles HTTP Responses. It can be implemented using a custom implementation to levarage testability.", 
            "title": "HTTPRemote"
        }, 
        {
            "location": "/lynx/remote/#client", 
            "text": "Client is the default remote TCP Client implementation. It handles serialization of responses and has an extension point for error handling.", 
            "title": "Client"
        }, 
        {
            "location": "/lynx/remote/#error-handling", 
            "text": "Client.errorHandler  is a variable that can be assigned a closure that handles errors that are  Encodable . This is especially useful for responding to the Client with a JSON serialized Error.  For example:  // HTTP\nimport Lynx\n\n// JSON\nimport Cheetah\n\nClient.errorHandler = { error, client in\n  dp {\n    // Attempt to encode the error\n    let jsonError = JSONEncoder().encode(error)\n    let response = Response(status: 500, body: jsonError)\n\n    // Send the error\n    try client.send(response)\n\n    // Close the connection\n    client.close()\n  } catch {\n    // If the above failed, just close the connection\n    client.close()\n  }\n}", 
            "title": "Error handling"
        }, 
        {
            "location": "/lynx/remote/#testclient", 
            "text": "TestClient is primarily useful in unit tests.  It accepts both an successful response and error handler  let client = TestClient({ response in\n  XCTAssertEqual(response.status.code, 200)\n}, or: { error in\n  XCTFail( \\(error) )\n})  When you've created a testClient, you can pass it together with a request directly in the router or HTTP server.  let request = Request(method: .get, path:  / )\n\n// Only need one of these 2\nrouter.handle(request, for: client)\nserver.handle(request, for: client)", 
            "title": "TestClient"
        }, 
        {
            "location": "/third-party/jobs/", 
            "text": "Jobs by \nBrett Toomey\n\n\nJobs is a minimalistic job system. It doesn't store the jobs cross-application, and doesn't allow restarting jobs after application exit.\n\n\nIt is, however, extremely useful for simple tasks such as sending a notification, ping or other non-critical jobs.\n\n\nSPM\n\n\nAdd the following dependency to your \nPackage.swift\n\n\nSwift 4\n\n\n.package(url: \nhttps://github.com/BrettRToomey/Jobs.git\n, from: Version(1,0,0)),\n\n\n\n\nSwift 3\n\n\n.Package(url: \nhttps://github.com/BrettRToomey/Jobs.git\n, majorVersion: 1),\n\n\n\n\nUsage\n\n\nWhenever you have a source file that needs to execute a Job, add the following import.\n\n\nimport Jobs\n\n\n\n\nSpecifying time\n\n\nAll specified time is specified as a \nDuration\n.\n\n\nDurations come in three types, \n.seconds\n, \n.days\n and \n.weeks\n.\nAlternatively you can access them as properties on an int.\n\n\n// The same\nlet oneMinute = 60.seconds\nlet alsoOneMinute = Duration.seconds(60)\n\n// The same\nlet twoDays = 2.days\nlet alsoTwoDays = Duration.days(60)\n\n// The same\nlet fiftyWeeks = 50.weeks\nlet alsoFiftyWeeks = Duration.weeks(50)\n\n\n\n\nRunning a job\n\n\nRunning a repeating job can be useful, even if it's only used temporarily.\n\n\nA job might send an update to a user over WebSocket every 30 seconds.\n\n\n// Creates a job that executes every 30 seconds\nlet job = Jobs.add(interval: 30.seconds) {\n  // execute job\n}\n\n\n\n\nStopping a job\n\n\nStopping a job is as simple as this:\n\n\njob.stop()\n\n\n\n\nAutostart versus manual starting\n\n\nJobs start automatically by default, sometimes you need to start them when an event happens.\n\n\nFor example; a job might update clients over WebSocket only after the client sends a message requesting updates. But the job can be created in advance. It can also be stopped and restarted again.\n\n\n// Creates a job that executes every 30 seconds\nlet job = Jobs.add(interval: 30.seconds, autoStart: false) {\n  // execute job\n}\n\njob.start()", 
            "title": "Jobs"
        }, 
        {
            "location": "/third-party/jobs/#jobs-by-brett-toomey", 
            "text": "Jobs is a minimalistic job system. It doesn't store the jobs cross-application, and doesn't allow restarting jobs after application exit.  It is, however, extremely useful for simple tasks such as sending a notification, ping or other non-critical jobs.", 
            "title": "Jobs by Brett Toomey"
        }, 
        {
            "location": "/third-party/jobs/#spm", 
            "text": "Add the following dependency to your  Package.swift", 
            "title": "SPM"
        }, 
        {
            "location": "/third-party/jobs/#swift-4", 
            "text": ".package(url:  https://github.com/BrettRToomey/Jobs.git , from: Version(1,0,0)),", 
            "title": "Swift 4"
        }, 
        {
            "location": "/third-party/jobs/#swift-3", 
            "text": ".Package(url:  https://github.com/BrettRToomey/Jobs.git , majorVersion: 1),", 
            "title": "Swift 3"
        }, 
        {
            "location": "/third-party/jobs/#usage", 
            "text": "Whenever you have a source file that needs to execute a Job, add the following import.  import Jobs", 
            "title": "Usage"
        }, 
        {
            "location": "/third-party/jobs/#specifying-time", 
            "text": "All specified time is specified as a  Duration .  Durations come in three types,  .seconds ,  .days  and  .weeks .\nAlternatively you can access them as properties on an int.  // The same\nlet oneMinute = 60.seconds\nlet alsoOneMinute = Duration.seconds(60)\n\n// The same\nlet twoDays = 2.days\nlet alsoTwoDays = Duration.days(60)\n\n// The same\nlet fiftyWeeks = 50.weeks\nlet alsoFiftyWeeks = Duration.weeks(50)", 
            "title": "Specifying time"
        }, 
        {
            "location": "/third-party/jobs/#running-a-job", 
            "text": "Running a repeating job can be useful, even if it's only used temporarily.  A job might send an update to a user over WebSocket every 30 seconds.  // Creates a job that executes every 30 seconds\nlet job = Jobs.add(interval: 30.seconds) {\n  // execute job\n}", 
            "title": "Running a job"
        }, 
        {
            "location": "/third-party/jobs/#stopping-a-job", 
            "text": "Stopping a job is as simple as this:  job.stop()", 
            "title": "Stopping a job"
        }, 
        {
            "location": "/third-party/jobs/#autostart-versus-manual-starting", 
            "text": "Jobs start automatically by default, sometimes you need to start them when an event happens.  For example; a job might update clients over WebSocket only after the client sends a message requesting updates. But the job can be created in advance. It can also be stopped and restarted again.  // Creates a job that executes every 30 seconds\nlet job = Jobs.add(interval: 30.seconds, autoStart: false) {\n  // execute job\n}\n\njob.start()", 
            "title": "Autostart versus manual starting"
        }
    ]
}